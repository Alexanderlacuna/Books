* R/QTL2 developer guide
r-qtl2 is a reimplementation for the r-qtl,
qtl means quantitave trait loci
location in chromosomes  (genetic loci)
that influence trait in an individual
QTL mapping - statistical method
to map the trait to the genetic loci in a chromosome
In this document, we'll describe the technical details of interests to those
interested in contributing the rqtl package
This package (rqtl-2) can be divided into three sectionsa/aspects


** A hidden Markov model (HMM)
this it calculate QTL genotype probabities given genetic marker data
and to estimate genetic maps. This is coded in C++.
Each possiblc cross type is  class inherited from the class QTLCROSS
We're using Rcpp to connect from R to C++

Question:
- [] what is genetic marker data?
- [] what is a genetic map
  
** Linear regression
This is for QTL Mapping  by HAley-Knott regression.
We're using RcppEigen and the Eigen Linerar algebra libary

** Linear Mixed models

for handling varying relatedness among individuals. again
using RcppEigen and the *Eigen linear algebra library*


We are redefining the basic data structures to be more general
(to handl more complex crosses, such as the collaborative
cros, magic lines  and Diversity outcross) ad to incorporate
more information such as annotations of the phenotypes
(for example with gene expression data, the gene
indetifiers, physical locations of genes and the
tissue that was measured)

We are also defining th input data file format

**  installation
#+BEGIN_SRC r
install.packages("qtl2")

#+END_SRC

** data file format
the input data file format for r/qtl cannot handle handle complex crosses
and so r/qtl2 we have defined a new format for the data files.



Qtl mappign data consists of a set of table of data: marker genotypes,
phenotypes, marker maps. etc.  In the new format these different tables
are in  separate comma - delimited(CSV) files.
In each file, the first column  is a set of IDS for the rows and
the first row is a set of ids  of the columns
For example, the phenotype data file will have individual IDs in the
first column  and phenotypes names in the first row


A few important changes in the tabular data

1. we will use not ust the genetic marker map but also a  physical map (if available)
2. Previously, pheotypes and covariates were combined, In thenew format, we
   separate numeric phenotypes from the oftern non-numeric covariates

3. We define a table of phenotype covariates. Theses are metadata
   describing the phenotypes for example in the case of a phenotype
  measured over time, one column in the phenotype covariate data could be
  the time of measurement. For gene expression data, we would
  have columns representing chromosome and physical position of genes,
  as well as gene IDS

In addition to the set of CSV files with the primary data, we need
a separate control file with various control parameters or metadata,
including the name of all the other data files and the genotype
codes used in the genotype data file.
The control file is a specific format using either `YAML` or `JSON`
theses are human-readble text-files for representing relatively complex data


A big advantage of the control file scheme is that it
greatly simplies the function for reading in the data
The function, read_cross2, has a single argument;
the name(with path) of the control file.
So you can read in data like this

**control file loading**
#+BEGIN_SRC R
library(qtl2)
grav2 <-  read_cross2("~/my_data/grav2.yaml")
#+END_SRC


The large number of files is a bit cumbersome, so we've made it possible
to use a zip file containing all of the data files, and  to read that zip
file directly.

There's even a function for creating in the zip file
#+BEGIN_SRC R
zip_datafiles("~/my_data/grav2.yaml")
#+END_SRC

The `zip_datafiles()` function will read the control file to identify all of the
relevant data files and then zip them up into a file with  the same name
and location, but with the extension  `.zip ` ratherthatn `.yaml` or `.json`

To read the data back in, we use the same read_cross2() function ,
providing the name (and path) of the zip file rather tatn the cross file

#+BEGIN_SRC R
 grav2 <- read_cross2("~/my_data/gav2.zip")
#+END_SRC

This can even be done with remote files


#+BEGIN_SRC R
grav2 <- read_cross2("https://kbroman.org/qtl2/assets/sampledata/grav2/grav2.zip")
#+END_SRC

The other advantage of the zip file is that is that it is compressed and
so small than the combined set of CSV files.

The control file may be confusing for some user. To assist in its construction,
there is a function `write_control_files() ` that takes the large set of control
parameters as input and then writes the YAML or JSON control file in the appropriate
format 





** Sample Data sets

The r/qtl2 web site includes sample data files in the new format.
Zipped versions of these datasets are included with qtl2 package
and can be loaded into R using the read_cross2() function

In the qtl2 package souce, the sample zup files are located in
`qtl2/inst.extdata`. In the installed version of the package, they

ae in qtl2/extdata, within whatever directory your R packages
were installed. The R function system.file() can be used to construct
the path to these files.
For example, one of the sample data sets concerns a gravitropism phenotype
in a set of Arabidopsis recombinant inbred lines(RIL) from `Morre et al. (2013) Genetics
195:1077-1086`




#+BEGIN_SRC r
library(qtl2)
grav2 <- read_cross2(system.file("extdata", "grav2.zop" , package="qtl12"))
#+END_SRC


** Calculating genotype probabilities
Big question
1. What is genotype probabilities??? 
computation of inheritance probabities
The first basic task in the QTL analysis is to calculate conditional
genotype probabilities, given the observed marker data at each
putative QTL position.
This is accomplished with the `calc_genoprob()`  function.
Unlike the corresponding function R/qtl , the resukts
is not inserted back into the input cross object but is
returned  as a list of three dimensional
arrays (one per chromosomes)  Each 3d array of probabilities
i arranged as (individual * genotypes  * positions)

If we wish to perform QTL calculations at position between
markers (so called pseudomarkers)  we first need to insert
such position into the genetic map with the function
`insert_pseudomarkers() ` Unlike R/qtl the mao
is kept separate from the genotype probabilities


`From the docs`

we'll use the iron dataset from Grant et al(2006)
Hepatology 44.174-185 ( an intercrss) as an example
WE FIRST load the data.

#+BEGIN_SRC R
library(qtl2)
iron <- read_cross2(system.file("extdata", "iron.zip" , package="qtl2"))
#+END_SRC


We then user `insert_pseudomarkers()` to insert pseudomarkers into the
genetic map. which we grab from the iron object as iron$gmap

#+BEGIN_SRC R

map <- insert_pseudomarkers(iron$gmap, step=1)

#+END_SRC

And next we use `calc_genoprob()` to calculate the QTL genotype probabilities

#+BEGIN_SRC R
 
pr <- calc_genoprob(iron, map,  error_prob = 0.002)
#+END_SRC


To speed up the calculations with large dataset on a multi-core machine
you can use the argument cores. With cores = 0, the number
of available cores will be detected via prallel::detectCores().
Otherqise, specify the number of cores as a positive integer.

#+BEGIN_SRC R

pr <- calc_genoprob(iron, map, error_prob = 0.002, cores =4)  

#+END_SRC


The genome scan functions ( see below) use genotype probabilities as
we as a matrix of phenotypes. If you wished to perform
a genome scan via and additive allele model ( what is additve
allele and additive allele model), you would first convert
the genotype probabilitest to allele probabilites,
using the function  geneprob_to_alleleprob(pr)

#+BEGIN_SRC R
apr <- genoprob_to_alleleprob(pr)
#+END_SRC

** Calculating a kinship matrix

What is  a  kinship Matrix???
https://www.youtube.com/watch?v=OcOWHGAo53M

Probability that inbred has  the sam allele for example A1A1
Kinship probability that two related individual would have
the same genetic markup  for the same locus


If you wish to perform a genome scan by a linear mixed model,
account for the relationship among individuals( in other words
including a random polygenic effect), you'll need
to  calculate a kinship matrix for the individuals.
This is accomplished with the `calc_kinship()`
function. It takes the genotypes probabilities as
input
#+BEGIN_SRC R
kinship <- calc_kinship(pr)
#+END_SRC 


By default the genotype probabities are converted to allele
probabilites, and the kinsip matrix is calculated as the
proportion of shared alleles.
To use genotype probabilites instead
use  use_allele_probs=FALSE. Further, by
default we calculate the kinship using both the autosomes
and X chromosomes. To omit the X chromosome,
we omit_x=True

In calculating the kinship matrix, one may wish to eliminiate
the effect of varying marker across the genome and only
use probabilites along the grid of pseudomarkers
(defined by the `step` argument to `insert_pseudomarkers()`
To do so, we need to first use `calc_grid()` to determine
the grid of pseudomarkers and then probs_to_grid
to omit probabilites for positions that are not on the grid.

#+BEGIN_SRC R
  grid <- calc_grid(iron$gmap, step=1)
  pr_grid <- probs_to_grid(pr, grid)
  kinship_grid <- calc_kinship(pr_grid)

#+END_SRC

If, for you linear mixed model genome scan , you wish to use
the `Leave one chromosome out (LOCO) `method (scan each
chromosome using kinship matrix that is calculated
using data from all other chromosomes)  use type="loco"
in the call to `calc_kinship()`


#+BEGIN_SRC R
kinship_loco <- calc_kinship(pr, "loco")
#+END_SRC


On a multi- machine , You can get some speed-up via the cores
argument, as with calc_genoprob().


#+BEGIN_SRC R
kinship_lock <- calc_kinship(pr, "loco" , cores=4)
#+END_SRC



** Special covariates for the X chromosomes

In a QTL scan of the X chromosome, special covariates(such as sex)

may need to be included under the null hypothesis of no
to avoid spurious evidence of linkage (see https://doi.org/10.1534/genetics.106.061176)

The particular X chromosome covariates  depends on the cross,
and can be obtained with the function get_x_covar()

#+BEGIN_SRC R
Xcovar <- get_x_covar(iron)
#+END_SRC


** Performing a Genome scan
What is a genome scan?
